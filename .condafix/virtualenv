#!/bin/bash
#
# Okay, I think this should work.
#
# Every time I ran "virtualenv" inside of a conda environment, it would
# die with "ValueError: failed to parse CPython sys.version".  So for a
# while I simply avoided using "virtualenv" while Anaconda was active.
# But now I need to use the virtualenv-powered "tox" tool in a project.
# My hand has been forced.
#
# So I looked at the incomplete virtual environment's "bin/python2.7"
# and found the tiny 8,106-byte Python binary that Anaconda ships.  It
# usually links to their own "libpython2.7.so" and therefore has their
# crazy non-standard (what were they thinking?) sys.version string that
# is a perfect match for the regular expression in their crazy non-
# standard "platform.py".  But running "ldd" on the environment's
# "bin/python2.7" showed it linking to the Ubuntu "libpython2.7.so"
# instead, which explains the problem: the virtualenv is a collision
# between the normal "libpython2.7.so" and the non-standard Anaconda
# "platform.py".
#
# How does the Anaconda Python binary usually wind up linking to their
# intended "libpython2.7.so" instead of Ubuntu's?  By, it turns out,
# having a relative RPATH - that only works if their Python binary is
# sitting right next to the "lib" directory containing libpython:
#
# $ readelf -d anaconda/bin/python2.7 | grep RPATH
# 0x0000000f (RPATH)                      Library rpath: [$ORIGIN/../lib]
#
# This situation obviously does not pertain in a new virtualenv since it
# only copies in a minimal ".../lib/pythonX.Y" directory, not any shared
# libraries into "../lib" itself.  Hence the fact that the linker falls
# back to discovering and linking in the system "libpythonX.Y.so".
#
# This shell script intends to provide a remedy.

# First, we will be entirely unable to call the real "virtualenv" unless
# we remove our own directory from $PATH first, so:

PATH="${PATH/$HOME\/.condafix:/}"

# Second, there might be several conda-powered directories on my PATH.
# For example, I might have put both an Anaconda for Python 2.7 and for
# Python 3.4 on my PATH before running "tox".  So I find everything on
# the PATH that looks like "~/.v/FOO" and build a linker library path
# with all of the corresponding "~/.v/FOO/lib" directories.  That way,
# even when "virtualenv" has copied a Python binary somewhere new and
# its RPATH is useless, the linker will still be able to find the right
# "libpython" to link to.

export LD_LIBRARY_PATH=
OLD_IFS="$IFS"
IFS=":"

for p in $PATH
do
    if [[ $p == $HOME/.v/* ]]
    then
        LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${p%bin}lib
    fi
done

IFS="$OLD_IFS"
LD_LIBRARY_PATH=${LD_LIBRARY_PATH#:}  # remove leading ":"

# We can now invoke the real virtualenv.

virtualenv "$@" || exit $?

# The result should be a virtual environment that operated correcly
# (which "virtualenv" will have tested, by calling the "bin/python"
# binary that it placed inside) only because our LD_LIBRARY_PATH is set.
# To keep the environment working once this script exits, we need to
# copy in all of the "libpython*" libraries that it could need.  They
# will be found thanks to the RPATH of Anaconda Python binaries.

NEWENV="${@: -1}"

# Of course, the user might have simply called "virtualenv" with an
# argument like "--help", so we should exit if the final argument does
# not in fact appear to be a directory.  (Let's just forget for the
# moment the possibility that they put options *after* the destination
# directory name.)

if [ ! -d "$NEWENV" ]
then
    exit
fi

# Otherwise, we proceed.

echo -n "Copying in Anaconda libpythons..."
IFS=":"

for p in $LD_LIBRARY_PATH
do
    cp -a $p/libpython* $NEWENV/lib
done

echo "done."
